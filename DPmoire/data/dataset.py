import numpy as np
import re
from ase.units import kJ, m
from ase import Atoms
from ase.io import write as asewrite
from ase.io import read as aseread
from ase.io.vasp import read_vasp_out
from ase.calculators.singlepoint import SinglePointCalculator
import copy

class Dataset:

    '''
    Dataset class to collect the AB_initio dataset generated by VASP_MLFF.
    '''

    n_configs = None
    data = None

    def __init__(self):
        self.n_configs = 0
        self.data = []
    
    def __getitem__(self, i:int):
        return self.data[i]
    
    def __setitem__(self, i:int, val):
        self.data[i] = copy.deepcopy(val)
        return i
    
    def _as_list(self):
        return self.data
    
    def __repr__(self):
        return str(list(self))

    def load_dataset_AB(self, infile_str, skip_configs:int=0):
        '''
        load dataset from ML_AB file of VASP_MLFF module.
        '''
        infile = open(infile_str)
        for i, lines in enumerate(infile):
            if i == 4:
                #read the number of structure in this file.
                self.n_configs += int(lines.split()[0])                      
                break
        dataset = infile.read()
        infile.close()
        #cut the file into pieces
        structures = re.split("\n+\s*Configuration num.\s*\d+\n",dataset)  
        #pop out the header
        structures.pop(0)
        #handle each configs
        for structure in structures[skip_configs:]:
            para = re.split("=+\n",structure)
            n_type = int(para[2].split("\n")[2])
            n_atom = int(para[3].split("\n")[2])
            elems = []
            n_elem = []
            energy = 0

            #read elements and how many atoms in each element
            for lines in para[3].split("\n")[6:6+n_type]:
                elems.append(lines.split()[0])
                n_elem.append(int(lines.split()[1]))

            #read lattice vectors of each cell
            lat_vec = []
            for lines in para[5].split("\n")[2:5]:
                lat = []
                for str in lines.split():
                    lat.append(float(str))
                lat_vec.append(lat)

            #read position of each atom
            pos = []
            symbol = []
            k = 0
            for i, lines in enumerate(para[6].split("\n")[2:2+n_atom]):
                posP = []
                for str in lines.split():
                    posP.append(float(str))
                pos.append(posP)
                #and assign the element symbol to them.
                if(n_elem[k]>0):
                    n_elem[k] -= 1
                else:
                    k += 1
                    n_elem[k] -= 1
                symbol.append(elems[k])

            #read energy of each configuration
            
            energy = float(para[7].split("\n")[2])

            #read forces of each atom
            f = []
            for lines in para[8].split("\n")[2:2+n_atom]:
                fP = []
                for str in lines.split():
                    fP.append(float(str))
                f.append(fP)

            stress_lines = para[9].split("\n")
            xx_yy_zz = stress_lines[4].split()
            xy_yz_zx = stress_lines[8].split()
            
            # Fixed Convention & Units. Stress of nequIP (ASE) is defined in eV/(Ang^3), while VASP is defined in 
            # KBar and a REVERSED sign. See ase.io.vasp_parsers.vasp_outcar_parsers.convert_vasp_outcar_stress()
            # and https://github.com/mir-group/nequip/blob/main/nequip/nn/_grad_output.py#L346-L349
            bar = 100*kJ/(m^3)
            kbar = 1000*bar
            stress_tensor = -np.array([[float(xx_yy_zz[0]), float(xy_yz_zx[0]), float(xy_yz_zx[2])],
                                      [float(xy_yz_zx[0]), float(xx_yy_zz[1]), float(xy_yz_zx[1])],
                                      [float(xy_yz_zx[2]), float(xy_yz_zx[1]), float(xx_yy_zz[2])]])*kbar

            curr_atoms = Atoms(symbols=symbol, cell=lat_vec, positions=pos,pbc=True)
            calculator = SinglePointCalculator(curr_atoms, energy=energy, forces=f, stress=stress_tensor)
            curr_atoms.set_calculator(calculator)
            self.data.append(curr_atoms)


    def load_dataset_OUTCAR(self, infile_str, freq):
        '''
        Load dataset from vasp OUTCAR object using ase.io.read_vasp_out.
        Only capable for reading OUTCAR of relaxation or regular MD. 
        Invalid to read from OUTCAR of VASP_MLFF MODULE.
        '''
        outcarStructures = read_vasp_out(infile_str, ":")
        for i, structure in enumerate(outcarStructures):
            if i%freq != 0:
                continue
            self.load_dataset_Atoms(structure)

    def load_dataset_extxyz(self, infile_str):
        '''
        Load dataset from .extxyz file.
        '''        
        structures = aseread(infile_str, format='extxyz', index=":")
        for structure in structures:
            self.load_dataset_Atoms(structure)
    
    def load_dataset_class(self, dataset):
        for structure in dataset:
            self.load_dataset_Atoms(structure=structure)

    def load_dataset_Atoms(self, structure:Atoms):
        '''
        load dataset from ase.Atoms object.
        '''
        if isinstance(structure, Atoms):
            stored_structure = Atoms(positions=structure.get_positions(), symbols=structure.get_chemical_symbols(), 
                                     cell=structure.get_cell(), pbc=structure.get_pbc())
            calc = SinglePointCalculator(stored_structure, energy=structure.get_potential_energy(apply_constraint=False), 
                                         forces=structure.get_forces(apply_constraint=False), 
                                         stress=structure.get_stress(apply_constraint=False))
            stored_structure.calc = calc
            self.data.append(stored_structure)
            self.n_configs += 1
        else:
            raise Exception("Structure is not Atoms object!")

    def save_extxyz(self, savefile_str):
        '''
        save the dataset to .extxyz file.
        Copied from github.
        '''
        #Clear the existing content in outfile.
        
        asewrite(savefile_str, self.data, format='extxyz')